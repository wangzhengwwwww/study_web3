# 区块链密码学简介

[](https://github.com/FoundationalTasks/Weekly-Tasks/blob/main/%E7%AC%AC%201%20%E5%91%A8%20%E6%8E%8C%E6%8F%A1%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/2.%20%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E3%80%81%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6%E5%9F%BA%E7%A1%80/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80.md#%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AF%86%E7%A0%81%E5%AD%A6%E7%AE%80%E4%BB%8B)

## 一、对称密码算法

[](https://github.com/FoundationalTasks/Weekly-Tasks/blob/main/%E7%AC%AC%201%20%E5%91%A8%20%E6%8E%8C%E6%8F%A1%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/2.%20%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E3%80%81%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6%E5%9F%BA%E7%A1%80/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80.md#%E4%B8%80%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81%E7%AE%97%E6%B3%95)

**概述**

对称密码算法的主要特点是使用相同的密钥进行加密和解密。这类算法根据其加密方式大致可以分为两类：流密码和分组密码。区块链技术主要采用分组密码。流密码以数据流的形式逐位或逐字节加密，而分组密码则将数据分成固定大小的块进行加密。

**知名的对称密码算法包括：**

- **DES（Data Encryption Standard）：** 较老的加密标准，现已被认为不够安全。
- **3DES（Triple DES）：** 是 DES 的一个更安全的变体，通过三次加密过程增强安全性。
- **IDEA（International Data Encryption Algorithm）：** 一种强大的加密算法，常用于商业加密软件。
- **RC2, RC4, RC5：** 由 Ron Rivest 设计的一系列加密算法，其中 RC4 尤其流行，虽然现在被认为存在安全性问题。
- **Blowfish：** 是一种块加密算法，设计用来替代 DES。
- **AES（Advanced Encryption Standard）：** 现代加密标准，提供了高级的安全性，是目前使用最广泛的加密算法之一。

### 1. 流密码

[](https://github.com/FoundationalTasks/Weekly-Tasks/blob/main/%E7%AC%AC%201%20%E5%91%A8%20%E6%8E%8C%E6%8F%A1%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/2.%20%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E3%80%81%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6%E5%9F%BA%E7%A1%80/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80.md#1-%E6%B5%81%E5%AF%86%E7%A0%81)

- RC4：曾广泛用于 WEP 网络加密。
- SNOW 3G：在 3G 数据传输中用作加密算法。
- A5：用于 GSM 系统的加密。
- 祖冲之序列密码：在 4G 通信中用于加密。

### 2. 分组密码

[](https://github.com/FoundationalTasks/Weekly-Tasks/blob/main/%E7%AC%AC%201%20%E5%91%A8%20%E6%8E%8C%E6%8F%A1%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/2.%20%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E3%80%81%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6%E5%9F%BA%E7%A1%80/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80.md#2-%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81)

**概述**

分组密码是一种将长明文序列切分为固定长度段后，对每个段分别进行加密的方法。这类算法不仅用于加密数据，还广泛应用于构造随机数生成器、流密码、消息认证码（MAC）和哈希函数等。由于其安全性和高效性，分组密码算法如 DES、IDEA、AES 等得到了广泛的应用。

#### 2.1 DES

[](https://github.com/FoundationalTasks/Weekly-Tasks/blob/main/%E7%AC%AC%201%20%E5%91%A8%20%E6%8E%8C%E6%8F%A1%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/2.%20%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E3%80%81%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6%E5%9F%BA%E7%A1%80/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80.md#21-des)

- 开发与采用：DES 由美国 IBM 公司于 1992 年研制，基于现代密码学的基本理念。1976 年，它被美国国家标准局确认为联邦信息处理标准（FIPS），随后在全球范围内广泛使用。
- 技术细节：DES 的工作包括三个主要参数：密钥（key）、数据（data）和工作模式（mode）。加密过程中，数据以 64 位为一组进行处理，而 56 位的密钥用于加密或解密这些数据块。
- 安全性和遗留问题：尽管 DES 在早期被广泛使用，但其 56 位的密钥长度已不足以抵抗现代的攻击手段。例如，1999 年一个 DES 密钥在 22 小时 15 分钟内就被公开破解。尽管有理论上的弱点，实际中利用这些弱点进行攻击非常困难。为了提高安全性，可以使用 DES 的增强版本 3DES，虽然它也有已知的理论攻击方法。
- 替代和淘汰：DES 标准及其衍生算法 3DES 已逐步被更现代、安全的高级加密标准（AES）所取代。DES 自 1977 年发布以来服务了超过 20 年，直到 2000 年 AES 的推出，它才正式被新的加密标准所替代。

> **DES 现在已经不是一种安全的加密方法**，主要因为它使用的 56 位密钥过短。1999 年 1 月，distributed.net 与电子前哨基金会合作， 在 22 小时 15 分钟内即公开破解了一个 DES 密钥。也有一些分析报告提出了该算法的理论上的弱点，虽然在实际中难以应用。为了提供实用所需的安全性， 可以使用 DES 的派生算法 3DES 来进行加密，虽然 3DES 也存在理论上的攻击方法。DES 标准和 3DES 标准已逐渐被高级加密标准（AES）所取代。 另外，DES 已经不再作为国家标准科技协会（前国家标准局）的一个标准。

DES 自 1977 年公布后服务了 20 多年，直到 2000 年高级加密标准（AES）公布，替代 DES 成为新的加密标准。

#### 2.2 AES

[](https://github.com/FoundationalTasks/Weekly-Tasks/blob/main/%E7%AC%AC%201%20%E5%91%A8%20%E6%8E%8C%E6%8F%A1%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/2.%20%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E3%80%81%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6%E5%9F%BA%E7%A1%80/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80.md#22-aes)

**概述**

AES（高级加密标准）是一种加密标准，基于 Rijndael 加密算法，由美国国家标准与技术研究院（NIST）在 2001 年 11 月 26 日正式发布为 FIPS PUB 197 标准。

**技术细节**

- 分组长度：AES 算法将数据分组长度固定为 128 比特，以确保加密处理的统一性和效率。
- 密钥长度：AES 支持多种密钥长度选项，分别为 128 比特、192 比特和 256 比特。根据使用的密钥长度，AES 分为三个变体：AES-128, AES-192, 和 AES-256。
- 加密轮数：加密过程中的轮数（N）根据密钥长度不同而不同。AES-128 使用 10 轮加密，AES-192 使用 12 轮，而 AES-256 则使用 14 轮。这些加密轮数设计用于增强算法的安全性，使其能够抵御各种密码攻击。

**应用和安全性**

AES 因其强大的安全性和高效的性能成为了全球使用最广泛的加密标准之一。它被广泛应用于政府、金融和商业数据保护中，提供了一种坚固的防护措施，以防数据被未经授权的访问和窃取。

#### 2.3 分组密码工作模式

[](https://github.com/FoundationalTasks/Weekly-Tasks/blob/main/%E7%AC%AC%201%20%E5%91%A8%20%E6%8E%8C%E6%8F%A1%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/2.%20%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E3%80%81%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6%E5%9F%BA%E7%A1%80/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80.md#23-%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F)

**概述**

分组密码工作模式不是一种加密算法，而是描述如何在一个加密算法中重复使用密钥的方法。这些模式与加密算法如 DES 和 AES 搭配使用，以隐蔽明文的统计特性和数据格式，提高整体安全性，并降低数据被篡改、重放、插入和伪造等攻击的成功机会。

**主要工作模式**

1. **ECB（Electronic Codebook）**
   
   - 描述：最简单的模式，单独加密每个 128 位明文分组，每个分组使用相同的密钥。
   - 优点：简单，支持并行计算，没有误差传播。
   - 缺点：相同明文分组产生相同密文分组，可能暴露固定内容的明文。

2. **CBC（Cipher Block Chaining）**
   
   - 描述：明文分组在加密前与前一个密文分组进行异或操作。
   - 优点：安全性较高。
   - 缺点：存在错误传播，不支持并行计算。广泛应用于 SSL 和 IPSec。

3. **CFB（Cipher Feedback）**
   
   - 描述：将分组密码转化为流密码模式，使用前一密文分组的部分比特和秘钥进行加密。
   - 优点：适合加密小分组数据，通过更换初始向量（IV）可以有效隐藏明文内容。
   - 缺点：存在比特级的错误传播。

4. **OFB（Output Feedback）**
   
   - 描述：与 CFB 类似，但本次加密的输入是上一次加密的输出。
   - 优点：没有错误传播，解决了 CBC 和 CFB 的错误传播问题。
   - 缺点：需要频繁更换密钥或初始向量。

### 3. 对称密码算法小结

[](https://github.com/FoundationalTasks/Weekly-Tasks/blob/main/%E7%AC%AC%201%20%E5%91%A8%20%E6%8E%8C%E6%8F%A1%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/2.%20%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E3%80%81%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6%E5%9F%BA%E7%A1%80/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80.md#3-%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81%E7%AE%97%E6%B3%95%E5%B0%8F%E7%BB%93)

**核心特性**

对称密码算法的主要优势在于其开放性、低计算需求、快速加密速度和高加密效率。这些特性使得对称加密在需要快速处理大量数据的场景中非常有用。

**安全性挑战**

然而，对称加密也存在一些显著的安全挑战：

- **密钥管理：** 由于加密和解密使用相同的密钥，因此保证密钥的安全变得尤为重要。密钥在双方之间共享，必须通过绝对安全的通道传输，否则安全性无法保障。
- **密钥泄露风险：** 密钥的安全性高度依赖于其保存方式。如果密钥由多人知晓，泄露的风险显著增加，这可能导致加密信息的安全性大打折扣。

**总结**

虽然对称加密算法在性能上表现出色，但在使用过程中必须采取额外的安全措施来保护密钥，确保加密数据的安全性。密钥管理的策略和工具是保证对称加密算法有效安全运用的关键因素。

### 4. 对称密码算法在区块链中的应用

[](https://github.com/FoundationalTasks/Weekly-Tasks/blob/main/%E7%AC%AC%201%20%E5%91%A8%20%E6%8E%8C%E6%8F%A1%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/2.%20%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E3%80%81%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6%E5%9F%BA%E7%A1%80/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80.md#4-%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81%E7%AE%97%E6%B3%95%E5%9C%A8%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8)

虽然对称密码算法因其固有特性在区块链技术中的应用场景相对较少，但它在某些关键领域中扮演着重要角色。

**1. 数字钱包中的私钥管理**

在数字钱包的设计中，对称密码算法是保护用户私钥的一种常用手段。根据钱包的去中心化程度，可以分为全节点钱包、轻节点钱包和中心化钱包。这些钱包均具备密钥存储功能，即使用对称加密方法将用户的私钥、公钥和账户地址安全地存放在加密文件中。用户通过设置对称加密密码来访问和管理这些密钥。即便这些加密文件被泄露，由于对称加密的保护，私钥信息仍能在一定时间内保持安全。然而，一旦加密文件被泄露，用户应立即将资产转移至新的私钥对应的账户地址，并重新安全保存新的加密文件。

**2. 区块链网络层通信**

对称密码算法还广泛应用于区块链网络层的通信安全中，特别是在 TLS（传输层安全协议）中。TLS 利用对称加密算法来保证数据传输过程中的机密性和完整性，确保区块链网络通信不受中间人攻击和监听的威胁。

通过这些应用，对称密码算法在确保区块链技术的安全性和可靠性方面发挥了重要作用，特别是在提升交易和通信的安全性方面。

> 比特币官方使用 AES 加密用户的私钥文件。

## 二、非对称密码算法

[](https://github.com/FoundationalTasks/Weekly-Tasks/blob/main/%E7%AC%AC%201%20%E5%91%A8%20%E6%8E%8C%E6%8F%A1%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/2.%20%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E3%80%81%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6%E5%9F%BA%E7%A1%80/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80.md#%E4%BA%8C%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81%E7%AE%97%E6%B3%95)

**概述**

非对称密码算法，通常称为公钥加密算法，主要用于解决对称密码算法在认证和签名场景中的限制。这类算法使用一对密钥：一个公钥和一个私钥。这两个密钥具有互补性，即用其中一个密钥加密的信息，只能用另一个相应的密钥解密。

**特点与应用**

非对称密码算法在加解密效率上通常稍慢于对称密码算法，但提供了更高的安全性，特别是在数字签名和安全通信领域。这使得它们非常适合需要高安全性的场景。

**常见算法**

1. **RSA：** 基于大质因数分解难题，是最广泛使用的非对称加密算法之一。它既可用于加密数据，也常用于数字签名。
2. **Diffie-Hellman：** 专注于密钥交换，基于离散对数难题，允许两个无先前联系的方在不安全的通道上共享密钥。
3. **ElGamal：** 同样基于离散对数难题，提供加密和数字签名功能。
4. **ECC (Elliptic Curve Cryptography)：** 椭圆曲线密码算法，基于椭圆曲线上的离散对数问题。它因密钥长度较短而提供相同级别的安全保证，从而在效率上优于 RSA。ECC 被广泛用于移动设备和智能卡等资源受限环境。

**深入介绍：RSA 与 ECC**

- **RSA：** 首选于 1987 年由 MIT 研究人员提出，它的安全性依赖于大数分解的困难性，使得在实际应用中，如 SSL/TLS 协议中非常有效。
- **ECC：** 1985 年提出，已成为数字证书和区块链技术中的标准选择。ECC 不仅用于加密，也是生成区块链地址和执行数字签名的核心技术，如 Bitcoin 等主要加密货币使用的 ECDSA（基于椭圆曲线的数字签名算法）。

**总结**

非对称密码算法通过其独特的密钥结构提高了交易和通信的安全性。尽管在处理速度上可能不如对称密码算法，但其在保证数据安全性方面的能力使它在处理敏感和重要信息时成为不可或缺的工具。

## 三、Hash 函数

[](https://github.com/FoundationalTasks/Weekly-Tasks/blob/main/%E7%AC%AC%201%20%E5%91%A8%20%E6%8E%8C%E6%8F%A1%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/2.%20%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E3%80%81%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6%E5%9F%BA%E7%A1%80/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80.md#%E4%B8%89hash-%E5%87%BD%E6%95%B0)

哈希函数，也称为散列函数或单向加密算法，是一种将任意长度的输入数据转换成固定长度输出的函数。这些输出通常表现为一个较短的、固定长度的值或摘要，常用于确保数据的完整性。哈希函数的特点是高效且能快速地处理大量数据，同时其输出不易被逆向工程还原原始输入信息。

常见 Hash 函数有 MD4/MD5、RipeMD-160、SHA 系列函数以及 SM3 国密算法。

> MD5 和 SHA1 都被攻破，不能用于要求安全性较高的场景，区块链使用了 SHA-256 算法；

### 1. SHA

[](https://github.com/FoundationalTasks/Weekly-Tasks/blob/main/%E7%AC%AC%201%20%E5%91%A8%20%E6%8E%8C%E6%8F%A1%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/2.%20%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E3%80%81%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6%E5%9F%BA%E7%A1%80/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80.md#1-sha)

SHA 包含 SHA-[0~3]共四个系列，见下图（来自维基百科）

[![](https://github.com/FoundationalTasks/Weekly-Tasks/raw/main/%E7%AC%AC%201%20%E5%91%A8%20%E6%8E%8C%E6%8F%A1%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/2.%20%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E3%80%81%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6%E5%9F%BA%E7%A1%80/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF/static/NwrMbmx2qojutexD6Z6cBu6tnCg.png)](https://github.com/FoundationalTasks/Weekly-Tasks/blob/main/%E7%AC%AC%201%20%E5%91%A8%20%E6%8E%8C%E6%8F%A1%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/2.%20%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E3%80%81%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6%E5%9F%BA%E7%A1%80/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF/static/NwrMbmx2qojutexD6Z6cBu6tnCg.png)

SHA 系列应用在很多安全协议中，如 TLS、SSL、PGP、SSH、S/MIME 和 IPSec 等。

#### 1.1 Keccak 介绍

[](https://github.com/FoundationalTasks/Weekly-Tasks/blob/main/%E7%AC%AC%201%20%E5%91%A8%20%E6%8E%8C%E6%8F%A1%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/2.%20%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E3%80%81%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6%E5%9F%BA%E7%A1%80/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80.md#11-keccak-%E4%BB%8B%E7%BB%8D)

**简介**

Keccak 是一种革命性的加密哈希函数，由 Guido Bertoni、Joan Daemen、Michaël Peeters 和 Gilles Van Assche 四位专家设计。在 2012 年，它赢得了由美国国家标准与技术研究院（NIST）举办的 SHA-3 竞赛，随后被正式采纳为 SHA-3 标准。与传统的 SHA 算法不同，Keccak 采用了独特的“海绵结构”。

**海绵结构**

Keccak 的核心特征是其采用的海绵函数结构，这使得它能够输出可变长度的哈希值。这种结构分为两个主要阶段：

- **吸收阶段：** 在此阶段，输入数据被切割成固定大小的块，每个块依次与内部状态进行异或操作后，通过一个非线性的变换函数（通常是置换或混淆函数）更新内部状态。
- **挤出阶段：** 完成吸收后，内部状态通过多次迭代处理，最终输出最终的哈希值。输出长度可以根据实际需要调整，使其非常灵活。

**Keccak 的特性**

- **灵活性：** Keccak 允许用户自定义内部状态的大小和输出的长度，使其能够根据不同的安全需求和应用场景进行调整。
- **安全性：** Keccak 设计上的独特性提供了出色的抗碰撞性和抗预映射攻击的能力。
- **性能：**在硬件实现中，Keccak 显示出卓越的性能，特别适合于资源受限的环境，如物联网设备中。

**总结**

Keccak 作为 SHA-3 的胜出算法，不仅因其独特的加密结构和优异的性能受到认可，也因其高度的灵活性和强大的安全特性在各种应用场景中展现了巨大的潜力。

### 2. RipeMD-160

[](https://github.com/FoundationalTasks/Weekly-Tasks/blob/main/%E7%AC%AC%201%20%E5%91%A8%20%E6%8E%8C%E6%8F%A1%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/2.%20%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E3%80%81%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6%E5%9F%BA%E7%A1%80/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80.md#2-ripemd-160)

**概述**

RipeMD-160 是一种在 1996 年设计的哈希算法，基于 MD4 的设计原理开发。它是 RipeMD 系列中的一个增强版本，旨在提供比 MD4、MD5 和 RipeMD-128 更高的安全性，主要用于替代这些较早期的算法。

**特点**

- **安全性提升：** RipeMD-160 提供 160 位的输出，比 MD5 的 128 位输出更加安全，有效减少了碰撞的可能性。
- **应用场景：** 由于其增强的安全特性，RipeMD-160 常用于需要较高安全性的应用，如数字签名和区块链地址生成。

**其他版本**

- RipeMD-256/320：这两个版本提供更长的输出长度，分别是 256 位和 320 位，设计用于需要更高安全级别的场景。尽管它们提供了更强的安全性，但计算效率相对较低，因此在选择使用这些版本时需要根据具体的应用需求和环境进行权衡。

**总结**

RipeMD-160 及其变体如 RipeMD-256 和 RipeMD-320，提供了从基本到高级的安全选项，使它们适用于不同的技术和业务需求。在选择合适的哈希算法时，需要考虑安全性与效率之间的平衡，以确保最佳的性能和安全性。

### 3. Hash 函数在区块链中的应用

[](https://github.com/FoundationalTasks/Weekly-Tasks/blob/main/%E7%AC%AC%201%20%E5%91%A8%20%E6%8E%8C%E6%8F%A1%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/2.%20%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E3%80%81%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6%E5%9F%BA%E7%A1%80/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80.md#3-hash-%E5%87%BD%E6%95%B0%E5%9C%A8%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8)

Hash 函数在区块链中有着广泛的应用，主要场景包含账户地址生成、Merkle 树、交易 ID 生成等。

## 四、PKI

[](https://github.com/FoundationalTasks/Weekly-Tasks/blob/main/%E7%AC%AC%201%20%E5%91%A8%20%E6%8E%8C%E6%8F%A1%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/2.%20%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E3%80%81%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6%E5%9F%BA%E7%A1%80/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80.md#%E5%9B%9Bpki)

公钥基础设施（PKI）是一种综合性的框架，设计用于支持公钥加密和数字证书的管理。它包含了硬件、软件、人员、政策和程序等多个组成部分，涵盖密钥和数字证书的生成、管理、存储、分发以及撤销等全方位功能。

### 1. PKI 组成

[](https://github.com/FoundationalTasks/Weekly-Tasks/blob/main/%E7%AC%AC%201%20%E5%91%A8%20%E6%8E%8C%E6%8F%A1%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/2.%20%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E3%80%81%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6%E5%9F%BA%E7%A1%80/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80.md#1-pki-%E7%BB%84%E6%88%90)

一个典型的 PKI 包括 PKI 策略、软硬件系统、CA（Certificate Authority，证书机构）、RA（Registration Authority，注册机构）、证书发布系统和 PKI 应用等。

#### 1.1 PKI 策略

[](https://github.com/FoundationalTasks/Weekly-Tasks/blob/main/%E7%AC%AC%201%20%E5%91%A8%20%E6%8E%8C%E6%8F%A1%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/2.%20%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E3%80%81%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6%E5%9F%BA%E7%A1%80/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80.md#11-pki-%E7%AD%96%E7%95%A5)

**概述**

PKI 策略为组织提供了一个全面的信息安全框架，明确了使用密码学系统的方法和原则。这些策略不仅定义了如何管理和应用加密技术，还确保了整个组织的信息安全实践的一致性和可靠性。

**主要类型**

PKI 策略通常包含以下两种主要类型的指导方针：

1. **证书策略：**
   
   - 此策略规定了数字证书的使用条件和约束，包括证书的申请、审批、发放、使用及终止的规则。它为证书的生命周期管理提供了明确的标准和要求。

2. **证书操作声明（Certificate Practice Statement, CPS）：**
   
   - CPS 详细描述了证书颁发机构（CA）的运作方式，涵盖证书的签发、吊销和管理流程。此外，CPS 还规定了用户密钥的生成、存储和传递方式。
   - CPS 的透明度使得外部利益相关者能够评估 PKI 的可信度和安全性。这份声明为 PKI 实践提供了可信赖的基础，保障了用户和机构对 CA 操作的信任。

**总结**

通过明确的证书策略和详尽的证书操作声明，PKI 策略不仅增强了组织内部的信息安全管理，也提升了外部对组织 PKI 系统可靠性的信心。这种策略的制定和执行对于确保数字身份的安全性和数据交换的完整性至关重要。

#### 1.2 CA

[](https://github.com/FoundationalTasks/Weekly-Tasks/blob/main/%E7%AC%AC%201%20%E5%91%A8%20%E6%8E%8C%E6%8F%A1%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/2.%20%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E3%80%81%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6%E5%9F%BA%E7%A1%80/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80.md#12-ca)

**概述**

证书颁发机构（CA）是公钥基础设施（PKI）的信任基础。CA 负责发放数字证书、设置证书的有效期、管理证书吊销列表（CRL）以实现证书的吊销、管理用户密钥等任务。CA 掌管公钥的整个生命周期，涵盖签发、吊销和更新数字证书等各个环节。

**数字证书**

数字证书是用于证明公钥拥有者身份的电子文件，包含公钥信息、拥有者的身份信息以及 CA 对这份证书的签名等信息。用户可以通过浏览器查询启用 HTTPS 的网站的证书信息。ITU-T（国际电信联盟电信标准化部门）规定了统一的证书格式 X.509，目前包括 V1、V2 和 V3 三个版本。

**证书吊销列表（CRL）**

CRL 用于验证证书的有效性。证书被吊销后，CA 通过更新 CRL 来通知相关方哪些证书已失效。X.509 标准规定了 CRL 的格式。

**双证书服务**

在单证书服务中，数字证书主要用于签名。然而，许多 CA 提供双证书服务，即在提供签名证书的同时，还为用户生成一张加密证书。加密证书中存储了一个对称加密密钥，该密钥通常由签名证书中的公钥派生而来。加密证书产生后，使用签名证书中的公钥进行加密，并与签名证书一起发给用户。用户可以使用私钥对加密证书进行解密，以获得加密密钥。

- **单证书服务：** 网站使用签名证书进行私钥签名和公钥加密（数据传输）。
- **双证书服务：** 签名证书仅用于签名以便用户验证网站身份，加密功能则由加密证书中的密钥负责。此外，CA 通常会留存加密证书中的密钥，以便政府监管和在网站遗失加密证书时申请恢复。

**密钥管理中心（KMC）**

密钥管理中心（KMC）是 CA 中的一个组件，负责密钥的生成、管理、更新、恢复和查询。KMC 通常在 CA 服务器上运行，而不是一个单独的机构。

> 另外，这部分内容还包含证书申请与吊销流程、证书链与证书验证流程，由于不是本文重点，所以此处不再赘述，有兴趣的读者请自行查询相关内容。

#### 1.3 RA

[](https://github.com/FoundationalTasks/Weekly-Tasks/blob/main/%E7%AC%AC%201%20%E5%91%A8%20%E6%8E%8C%E6%8F%A1%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/2.%20%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E3%80%81%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6%E5%9F%BA%E7%A1%80/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80.md#13-ra)

**概述**

注册机构（RA）是用户与证书颁发机构（CA）之间的重要桥梁。RA 负责获取和认证用户的身份，然后向 CA 发送申请证书的请求。在较小规模的 PKI 系统中，RA 的功能可以整合到 CA 中以节约成本。然而，为了提高 PKI 系统的安全性，国际标准建议使用独立的 RA 来实现用户注册功能。

**功能与角色**

- **身份认证：** RA 负责验证用户的身份信息，确保申请证书的用户身份真实可信。
- **申请证书：** 经过身份认证后，RA 向 CA 发送证书申请请求，并跟踪申请的进展和结果。

**建议与实践**

在实际应用中，尽管将 RA 功能整合到 CA 中可以节约成本，但为了增强系统的安全性和信任度，国际 PKI 标准建议保持 RA 和 CA 的独立性。这种分离不仅有助于分散风险，还能提升整个 PKI 系统的安全性和可靠性。

#### 1.4 证书发布系统

[](https://github.com/FoundationalTasks/Weekly-Tasks/blob/main/%E7%AC%AC%201%20%E5%91%A8%20%E6%8E%8C%E6%8F%A1%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/2.%20%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E3%80%81%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6%E5%9F%BA%E7%A1%80/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80.md#14-%E8%AF%81%E4%B9%A6%E5%8F%91%E5%B8%83%E7%B3%BB%E7%BB%9F)

**概述**

证书发布系统负责实现数字证书的发放和管理。它通过 LDAP 服务器向用户提供证书和证书吊销列表（CRL）的下载服务。

**功能与实现**

- **证书发放：** 将经过 CA 签发的证书发布给用户。
- **证书与 CRL 下载：** 用户可以通过 LDAP 服务器下载所需的证书和 CRL，以便进行身份验证和证书状态检查。

#### 1.5 PKI 应用

[](https://github.com/FoundationalTasks/Weekly-Tasks/blob/main/%E7%AC%AC%201%20%E5%91%A8%20%E6%8E%8C%E6%8F%A1%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/2.%20%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E3%80%81%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6%E5%9F%BA%E7%A1%80/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80.md#15-pki-%E5%BA%94%E7%94%A8)

**概述**

PKI 应用是基于 PKI 的证书和密钥来实现特定功能的一些系统。这些应用利用 PKI 的数字证书进行身份认证，并使用非对称加密进行密钥协商。

**典型应用**

- VPN（虚拟专用网络）：通过 PKI 实现安全的远程访问，利用数字证书验证用户身份，并建立加密通信通道。
- TLS（传输层安全协议）：保护互联网通信安全，基于 PKI 的数字证书进行服务器和客户端的身份验证，然后通过非对称加密完成密钥协商，确保数据传输的机密性和完整性。

**实现原理**

这些系统通过以下步骤实现安全通信：

1. 身份认证：使用 PKI 的数字证书来验证通信双方的身份。
2. 密钥协商：通过非对称加密算法协商生成对称加密密钥，用于后续的数据加密传输。

### 2. PKI 与区块链

[](https://github.com/FoundationalTasks/Weekly-Tasks/blob/main/%E7%AC%AC%201%20%E5%91%A8%20%E6%8E%8C%E6%8F%A1%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/2.%20%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E3%80%81%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6%E5%9F%BA%E7%A1%80/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80.md#2-pki-%E4%B8%8E%E5%8C%BA%E5%9D%97%E9%93%BE)

**概述**

在公链中，节点可以自由地加入或退出网络，无需任何门槛。但在联盟链中，节点的准入需要授权，并且需要对节点进行访问控制。仅使用数字签名技术无法实现身份认证和访问控制，因此需要通过数字证书将密钥与密钥拥有者的身份信息联系起来。

**数字证书在联盟链中的作用**

联盟链中的节点主要与链内其他节点进行通信，因此节点证书可以由区块链内部被大多数节点信任的一个或多个 CA（证书颁发机构）生成，而不必依赖外部第三方可信 CA。这样可以满足联盟链网络中各节点之间的身份认证需求。

**MSP（Member Service Provider）**

除了 CA，联盟链还需要一个实现密钥生成与管理等功能的服务，这个服务通常称为 MSP。MSP 是区块链上的一个身份认证和权限管理的抽象逻辑组件，负责认证所有可能与网络建立联系的节点，确保只有经过授权的节点才能通过验证。

**MSP 的功能和配置**

- **身份认证：** 通过维护一个可信 CA 列表（包括 CA 证书）和 CRL（证书吊销列表），MSP 在验证节点身份时发挥重要作用。证书验证过程是一个“证书链”验证过程，直到找到一个颁发者是区块链上的可信 CA，证书验证才完成。
- **权限管理：** MSP 可以配置相应的安全策略，如对 RPC 请求来源的验证、对等节点身份的验证、是否采用分布式 CA 等。
- **密钥管理：** MSP 初始化后，可以实现签名、验签、密钥生成等具体功能，确保节点之间的通信安全和数据完整性。

#### 2.1 区块链中的 CA

[](https://github.com/FoundationalTasks/Weekly-Tasks/blob/main/%E7%AC%AC%201%20%E5%91%A8%20%E6%8E%8C%E6%8F%A1%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/2.%20%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E3%80%81%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6%E5%9F%BA%E7%A1%80/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80.md#21-%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%AD%E7%9A%84-ca)

**概述**

在区块链中，CA（证书颁发机构）主要分为两种：本地 CA 和远程 CA。前者由本地系统掌握私钥，后者由远程系统掌握私钥，如中国金融认证中心（CFCA）。根据是否需要配置相同的可信 CA 列表，区块链中的 CA 又可分为中心式 CA 和分布式 CA。趣链区块链平台支持这两种类型的 CA。

**中心式 CA**

在中心式 CA 中，所有节点都需要配置一个 CRL（证书吊销列表）及一个相同的可信 CA 列表（内容为 CA 证书列表）。这些证书可以是本地 CA 或远程 CA 颁发的。在节点通信时，每个节点根据本地的 CA 列表验证对方节点发来的证书，同时发送自己的证书给对方进行验证。

**分布式 CA**

在分布式 CA 中，虽然所有节点仍需配置 CRL，但无需为所有节点配置相同的可信 CA 列表。相反，每个节点只需配置网络内所有 CA 对本节点颁发的证书。在与不同节点通信时，使用相应节点支持的 CA 颁发的证书。为了实现节点的动态添加，分布式 CA 只支持本地 CA，每个节点本质上都是一个 CA。新节点加入后，需要向网络中的所有 CA 申请证书，并记录在指定文件中，这样节点在重启后可以顺利地与其他节点进行通信。

#### 2.2 不同类型的证书

[](https://github.com/FoundationalTasks/Weekly-Tasks/blob/main/%E7%AC%AC%201%20%E5%91%A8%20%E6%8E%8C%E6%8F%A1%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/2.%20%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E3%80%81%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6%E5%9F%BA%E7%A1%80/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80.md#22-%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%AF%81%E4%B9%A6)

为了实现对节点和其他外部连接的访问控制，通常需要设计多种证书类型，节点持有不同类型的证书，代表拥有不同权限。例如，趣链区块链平台支持三种证书类型：

SDK 证书、节点准入证书、CA 证书。使用 SDK 访问链上数据时，需要提供 SDK 证书，否则不能建立连接；普通节点在加入区块链网络时，需要提供节点准入证书；

验证这些证书需要 CA 证书支持。

## 五、Merkle 树

[](https://github.com/FoundationalTasks/Weekly-Tasks/blob/main/%E7%AC%AC%201%20%E5%91%A8%20%E6%8E%8C%E6%8F%A1%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/2.%20%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E3%80%81%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6%E5%9F%BA%E7%A1%80/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80.md#%E4%BA%94merkle-%E6%A0%91)

Merkle 树，也称为哈希树，是一种用于存储哈希值的数据结构。其叶子节点包含原始数据的哈希值，非叶子节点则包含其子节点串联字符串的哈希值。

Merkle 树可以被视为哈希列表的扩展，通过构造树形结构的哈希验证路径，可以对完整数据中的单个分支进行独立验证，从而提高了完整性验证的效率。这种结构使得在区块链等系统中，可以高效地验证数据的完整性和一致性，而无需检查整个数据集。

### 1. 基于 hash 列表的完整性校验

[](https://github.com/FoundationalTasks/Weekly-Tasks/blob/main/%E7%AC%AC%201%20%E5%91%A8%20%E6%8E%8C%E6%8F%A1%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/2.%20%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E3%80%81%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6%E5%9F%BA%E7%A1%80/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80.md#1-%E5%9F%BA%E4%BA%8E-hash-%E5%88%97%E8%A1%A8%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7%E6%A0%A1%E9%AA%8C)

**概述**

哈希列表用于在 P2P 网络中进行数据传输的完整性校验。在 P2P 网络中，原始大数据块被分割成多个小数据块以实现分布式下载，最终合成完整的大数据块。通过构造哈希列表，可以有效地校验多个小数据块的完整性。

**过程**

1. **哈希计算：** 首先，计算每个小数据块的哈希值。这些哈希值再级联在一起进行一次哈希计算，得到哈希列表的根哈希值。

2. **下载与校验：**
   
   - 下载数据时，首先从可信的数据源获取正确的根哈希值。
   - 利用这个根哈希值，可以校验哈希列表的正确性。
   - 通过验证哈希列表，进而校验整个数据块的完整性。

这种方法确保了在数据分布式下载过程中，每个小数据块的完整性和正确性，最终保证整个大数据块的可靠性。

结构如下图

[![](https://github.com/FoundationalTasks/Weekly-Tasks/raw/main/%E7%AC%AC%201%20%E5%91%A8%20%E6%8E%8C%E6%8F%A1%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/2.%20%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E3%80%81%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6%E5%9F%BA%E7%A1%80/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF/static/D7RwbXVkyoTXW0xL8UUcXHvQnSf.png)](https://github.com/FoundationalTasks/Weekly-Tasks/blob/main/%E7%AC%AC%201%20%E5%91%A8%20%E6%8E%8C%E6%8F%A1%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/2.%20%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E3%80%81%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6%E5%9F%BA%E7%A1%80/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF/static/D7RwbXVkyoTXW0xL8UUcXHvQnSf.png)

### 2.基于 Merkle 树的完整性校验

[](https://github.com/FoundationalTasks/Weekly-Tasks/blob/main/%E7%AC%AC%201%20%E5%91%A8%20%E6%8E%8C%E6%8F%A1%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/2.%20%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E3%80%81%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6%E5%9F%BA%E7%A1%80/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80.md#2%E5%9F%BA%E4%BA%8E-merkle-%E6%A0%91%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7%E6%A0%A1%E9%AA%8C)

**概述**

Merkle 树的结构与哈希列表类似，但其相邻节点会合并计算生成一个新的哈希值作为上一层的节点。如果这一层是奇数个节点，则最后一个节点的哈希值直接上升至上一层。通过这种方式，最终会获得一个根节点和所有内部节点。

**过程**

1. **树的构建：**
   
   - 计算每个叶子节点（即原始数据块）的哈希值。
   - 将相邻的哈希值两两合并，再次计算哈希值，生成新的父节点。
   - 如果某一层节点数为奇数，则直接将最后一个节点的哈希值上升至上一层。
   - 重复此过程，直到生成单一的根节点。

2. **下载与校验：**
   
   - 在 P2P 网络下载之前，先从可信节点获取文件的 Merkle 树根节点。
   - 从其他不可信节点获取 Merkle 树的子节点。
   - 不同于哈希列表，Merkle 树允许下载和验证单独的分支。如果某个分支节点损坏，只需重新下载该分支节点。
   - 当文件较大时，Merkle 树的效率显著高于哈希列表，因为它可以快速定位并校验特定数据块的完整性。

这种结构确保了在数据传输过程中，每个数据块的完整性和正确性，显著提高了文件下载的效率和可靠性。

Merkle 树多指完全二叉树，也可以是完全多叉树。结构如下图

[![](https://github.com/FoundationalTasks/Weekly-Tasks/raw/main/%E7%AC%AC%201%20%E5%91%A8%20%E6%8E%8C%E6%8F%A1%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/2.%20%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E3%80%81%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6%E5%9F%BA%E7%A1%80/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF/static/SPVnbeYybopeUTxyKT4cej7rn9b.png)](https://github.com/FoundationalTasks/Weekly-Tasks/blob/main/%E7%AC%AC%201%20%E5%91%A8%20%E6%8E%8C%E6%8F%A1%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/2.%20%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E3%80%81%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6%E5%9F%BA%E7%A1%80/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF/static/SPVnbeYybopeUTxyKT4cej7rn9b.png)

## 六、数字签名技术

[](https://github.com/FoundationalTasks/Weekly-Tasks/blob/main/%E7%AC%AC%201%20%E5%91%A8%20%E6%8E%8C%E6%8F%A1%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/2.%20%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E3%80%81%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6%E5%9F%BA%E7%A1%80/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80.md#%E5%85%AD%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E6%8A%80%E6%9C%AF)

**概述**

数字签名技术利用私钥对数据进行加密运算，生成一串字符，以替代手写签名或印章。它用于确认消息来源，防止欺诈或消息伪造。

### 一、原理

[](https://github.com/FoundationalTasks/Weekly-Tasks/blob/main/%E7%AC%AC%201%20%E5%91%A8%20%E6%8E%8C%E6%8F%A1%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/2.%20%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E3%80%81%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6%E5%9F%BA%E7%A1%80/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80.md#%E4%B8%80%E5%8E%9F%E7%90%86)

数字签名技术基于公钥密码算法（非对称加密），在身份验证、数据源认证、完整性保护和不可否认性方面发挥重要作用。数字签名主要包括两部分：签名生成和签名验证。

签名生成与验证过程：

1. **签名生成：**
   
   - 选择一种公钥算法。
   - 使用私钥对原数据进行加密，生成签名字符串。

2. **签名验证：**
   
   - 验证方通过可信途径获取签名者的公钥，例如通过公钥数字证书。
   - 接收到签名后，计算原数据的摘要。
   - 使用公钥和验证算法解密签名字符串。
   - 比较解密后的数据摘要与接收到的原数据摘要，若一致则签名有效。

**详细步骤：**

1. 验证方通过可信途径获得签名者的公钥，例如通过公钥数字证书。
2. 接收到签名后，计算原数据的摘要，并使用验证算法进行验证，通过摘要比对判断签名的有效性。

### 二、可选方案

[](https://github.com/FoundationalTasks/Weekly-Tasks/blob/main/%E7%AC%AC%201%20%E5%91%A8%20%E6%8E%8C%E6%8F%A1%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/2.%20%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E3%80%81%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6%E5%9F%BA%E7%A1%80/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80.md#%E4%BA%8C%E5%8F%AF%E9%80%89%E6%96%B9%E6%A1%88)

- **RSA 签名：** 基于 RSA 算法，广泛应用于各种数字签名和加密场景。
- **椭圆曲线签名方案（ECDSA）：** 基于椭圆曲线密码学，提供更高效的安全性，适用于资源受限的环境。

## 七、零知识证明（Zero—Knowledge Proof，ZKP）

[](https://github.com/FoundationalTasks/Weekly-Tasks/blob/main/%E7%AC%AC%201%20%E5%91%A8%20%E6%8E%8C%E6%8F%A1%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/2.%20%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E3%80%81%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6%E5%9F%BA%E7%A1%80/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80.md#%E4%B8%83%E9%9B%B6%E7%9F%A5%E8%AF%86%E8%AF%81%E6%98%8Ezeroknowledge-proofzkp)

**概述**

零知识证明（ZKP）是在 20 世纪 80 年代初提出的，它允许证明者向验证者证明自己拥有某个秘密，而不泄露该秘密本身，即向外界透露的「知识」为零。零知识证明分为交互式和非交互式两种类型。

**零知识证明的三个重要性质**

1. **完备性（Completeness）：** 如果证明者确实拥有相应的知识，那么他们能够通过验证者的验证，即证明者有足够大的概率使验证者确信。
2. **可靠性（Soundness）：** 如果证明者没有相应的知识，则无法通过验证者的验证，即证明者欺骗验证者的概率可以忽略不计。
3. **零知识性（Zero-Knowledge）：** 在交互过程中，证明者仅向验证者透露是否拥有相应知识，而不会泄露任何关于知识的额外信息。

**关键点与应用场景**

从零知识证明的定义中可以提取两个关键词：“不泄露信息”和“证明论断有效”。基于这两个特点，零知识证明在区块链上有两个主要应用场景：

1. **隐私保护：**
   
   - 在隐私场景中，利用零知识证明的“不泄露信息”特性，可以在不泄漏交易细节（如接收方、发送方、交易金额）的情况下，证明区块链上的资产转移是有效的。

2. **扩容：**
   
   - 在扩容场景中，主要关注零知识证明的“证明论断有效”特性。由于链上资源有限，需要将大量计算迁移到链下进行，因此需要一种技术来证明链下发生的动作是可信的。零知识证明能够为链下可信计算提供支持。

### 1. 交互式零知识证明（Interactive Zero-Knowledge, IZK）

[](https://github.com/FoundationalTasks/Weekly-Tasks/blob/main/%E7%AC%AC%201%20%E5%91%A8%20%E6%8E%8C%E6%8F%A1%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/2.%20%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E3%80%81%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6%E5%9F%BA%E7%A1%80/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80.md#1-%E4%BA%A4%E4%BA%92%E5%BC%8F%E9%9B%B6%E7%9F%A5%E8%AF%86%E8%AF%81%E6%98%8Einteractive-zero-knowledge-izk)

交互式零知识证明是指证明者和验证者双方按照一个协议，通过一系列交互，最终验证者能够得出一个明确的结论，即证明者是否掌握某个秘密。

### 2. 非交互式零知识证明（Non-Interactive Zero-Knowledge, NIZK）

[](https://github.com/FoundationalTasks/Weekly-Tasks/blob/main/%E7%AC%AC%201%20%E5%91%A8%20%E6%8E%8C%E6%8F%A1%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/2.%20%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E3%80%81%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6%E5%9F%BA%E7%A1%80/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80.md#2-%E9%9D%9E%E4%BA%A4%E4%BA%92%E5%BC%8F%E9%9B%B6%E7%9F%A5%E8%AF%86%E8%AF%81%E6%98%8Enon-interactive-zero-knowledge-nizk)

交互式零知识证明（IZK）协议依赖于验证者的随机尝试，需要证明者和验证者进行多次交互才能完成验证。而非交互式零知识证明（NIZK）将交互次数减少到一次，实现了离线证明和公开验证。

> 区块链系统使用的就是这种，因为在区块链系统中，不能假设双方一直在线进行交互，在区块链网络上，证明者只要向全网广播一条证明交易，网络上的矿工在将 这条交易打包到区块中的时候就帮验证者完成了零知识证明的校验。

### 3. 发展历史

[](https://github.com/FoundationalTasks/Weekly-Tasks/blob/main/%E7%AC%AC%201%20%E5%91%A8%20%E6%8E%8C%E6%8F%A1%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/2.%20%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E3%80%81%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6%E5%9F%BA%E7%A1%80/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80.md#3-%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2)

- 1985 年：S. Goldwasser、S. Micali 和 C. Rackoff 首次提出了零知识证明（Zero-Knowledge Proof, ZKP）的概念。
- 2010 年：Groth 实现了首个基于椭圆曲线双线性映射的常数大小的非交互式零知识证明协议。该协议经过不断优化，最终演变成区块链中著名的零知识证明协议 SNARKs。
- 2013 年：Pinocchio 协议实现了分钟级别的证明、毫秒级别的验证，证明大小不到 300 字节，将零知识证明从理论应用到实践。Zcash 使用的 SNARKs 正是基于 Pinocchio 的改进版。
- 2014 年：名为 Zerocash 的加密货币使用了一种特殊的零知识证明工具 zk-SNARKs（Zero-Knowledge Succinct Non-interactive Arguments of Knowledge），实现了对交易金额和交易双方的完全隐藏，强调隐私和交易透明的可控性。
- 2017 年：Zerocash 团队提出了将 zk-SNARKs 与智能合约结合的方案，使得交易在众目睽睽之下隐身，打造保护隐私的智能合约。

**零知识证明开发工具**

为了满足零知识证明技术的广泛应用需求，已经开发出多个用于实现 zk-SNARK 零知识证明协议的开源算法库，包括 **libsnark**、**bellman** 和 **ZoKrates** 等。

### 4. 区块链如何应用零知识证明

[](https://github.com/FoundationalTasks/Weekly-Tasks/blob/main/%E7%AC%AC%201%20%E5%91%A8%20%E6%8E%8C%E6%8F%A1%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/2.%20%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E3%80%81%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6%E5%9F%BA%E7%A1%80/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80.md#4-%E5%8C%BA%E5%9D%97%E9%93%BE%E5%A6%82%E4%BD%95%E5%BA%94%E7%94%A8%E9%9B%B6%E7%9F%A5%E8%AF%86%E8%AF%81%E6%98%8E)

#### 4.1 隐私

[](https://github.com/FoundationalTasks/Weekly-Tasks/blob/main/%E7%AC%AC%201%20%E5%91%A8%20%E6%8E%8C%E6%8F%A1%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/2.%20%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E3%80%81%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6%E5%9F%BA%E7%A1%80/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80.md#41-%E9%9A%90%E7%A7%81)

在比特币交易过程中，为验证一笔交易是否合法，实际上只需验证以下三件事：

1. 发送方确实拥有足够的资金。
2. 发送方转出的金额和接收方收到的金额一致。
3. 发送方的资金确实被销毁。

在整个证明过程中，矿工实际上并不关心具体的交易金额、发送者身份或接收者身份。**矿工只关心系统中的资金是否守恒**。Zcash（大零币）正是基于这一思路，实现了隐私交易。

#### 4.2 扩容

[](https://github.com/FoundationalTasks/Weekly-Tasks/blob/main/%E7%AC%AC%201%20%E5%91%A8%20%E6%8E%8C%E6%8F%A1%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/2.%20%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E3%80%81%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6%E5%9F%BA%E7%A1%80/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80.md#42-%E6%89%A9%E5%AE%B9)

早期公链项目的 TPS（每秒交易数）非常低，例如比特币的 TPS 约为 7，以太坊的 TPS 约为 15。这意味着以太坊每秒只能处理 15 笔交易，如此低的 TPS 严重限制了区块链应用的大规模落地。因此，研究区块链扩容的问题变得至关重要，目标是提高链上的 TPS。

然而，区块链扩容受限于 Vitalik 提出的不可能三角理论，即区块链系统设计无法同时兼顾可扩展性、去中心化和安全性，三者只能取其二。这一结论虽然令人失望，但我们必须认识到，任何事物都有其边界。公链不应试图承担所有任务，而应专注于其核心使命：“公链是以最高效率达成共识的工具，能够以最低成本构建信任”。

作为共识的工具和信任的引擎，公链不应为了可扩展性而放弃去中心化和安全性。那么，如何在保持去中心化和安全性的同时，提升公链的 TPS 呢？一个有效的方法是将大量的工作放到链下处理，只将最重要的数据提交到区块链主链上，让所有节点都能够验证这些链下工作的准确性和可靠性。

区块链技术的发展也是如此，在底层区块链（Layer 1）上构建一个扩展层（Layer 2）。Layer 1 负责确保安全和去中心化，做到全球共识，并作为“加密法院”，通过智能合约设计的规则进行仲裁，以经济激励的形式将信任传递到 Layer 2 上。而 Layer 2 追求极致的性能，虽然只能实现局部共识，但能够满足各种商业场景的需求。

**链下扩容**

ZK-Rollup 是一种基于零知识证明的二层扩容方案。ZK-Rollup 方案起源于 2018 年下半年，由 Barry Whitehat 和 Vitalik 提出。Rollup 意为“卷起”和“汇总”，将大量交易“卷起/汇总”打包成一个交易。

**ZK-Rollup 的原理**

ZK-Rollup 的原理可以简要概述为：在链下进行复杂的计算和证明生成，链上进行证明的校验并存储部分数据以保证数据可用性。ZK-Rollup 的数据可用性允许任何人根据链上存储的交易数据，还原出账户的全局状态。

## 八、Base58 编码方案

[](https://github.com/FoundationalTasks/Weekly-Tasks/blob/main/%E7%AC%AC%201%20%E5%91%A8%20%E6%8E%8C%E6%8F%A1%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/2.%20%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E3%80%81%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6%E5%9F%BA%E7%A1%80/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80.md#%E5%85%ABbase58-%E7%BC%96%E7%A0%81%E6%96%B9%E6%A1%88)

**概述**

Base58 是一种 58 进制的编码方案，与 Base64 类似，基于 58 个可打印字符来表示二进制数据。这些字符包括阿拉伯数字和大小写英文字母。

**特点**

相比于 Base64，Base58 去掉了 6 个易混淆的字符：数字 0、大写 O、小写 l、大写 I 以及 +/，以便在任何字体中都能肉眼区分这些字符。这种设计使得 Base58 编码在需要高可读性的场景中（如区块链地址和密钥）更加实用。

> Base58 和 Base64 的缺点是会造成信息冗余，输出比输入大许多，所以这种编码方案只适合小数据。而且 Base58 与 Base64 不同的是，前者采用大数进制转换， 效率更低，所以使用场景更少。

Base64 普通应用于 URL，短文本，图片；Base58 一般用在比特币地址、私钥和脚本哈希场景。
